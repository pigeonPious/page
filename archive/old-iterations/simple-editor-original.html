<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üîß Simple Local Editor</title>
  <!-- REMOVED: <link rel="stylesheet" href="style.css"> to eliminate CSS conflicts -->
</head>
<body class="dark-mode">
<div class="menu-bar">
  <div class="menu-bar-inner">
    <div class="menu-star">*</div>
    <div class="menu-item"><div class="label" data-menu>File</div>
      <div class="menu-dropdown">
        <div class="menu-entry" onclick="localEditor.newDocument()">New</div>
        <a class="menu-entry" href="index.html">Back to Blog</a>
        <div class="menu-entry" onclick="localEditor.saveDraft()">Save Draft</div>
        <div class="menu-entry" onclick="localEditor.showDraftsList()">Load Draft</div>
        <div class="menu-entry" onclick="localEditor.exportPost()">Export Post</div>
        <div class="menu-entry" onclick="localEditor.manageDrafts()">Manage Drafts</div>
      </div>
    </div>
    <div class="menu-item"><div class="label" data-menu>Edit</div>
      <div class="menu-dropdown">
        <div class="menu-entry" onclick="localEditor.makeNote()">Make Note</div>
        <div class="menu-entry" onclick="localEditor.toggleRawMode()">Toggle Mode</div>
      </div>
    </div>
    <div class="menu-item"><div class="label" data-menu>View</div>
      <div class="menu-dropdown">
        <div class="menu-entry" data-mode="dark">Dark</div>
        <div class="menu-entry" data-mode="light">Light</div>
        <div class="menu-entry" onclick="localEditor.toggleRawMode()" id="view-mode-toggle">Visual Mode</div>
      </div>
    </div>
    <div class="menu-item"><div class="label" data-menu>Connect</div>
      <div class="menu-dropdown">
        <div class="menu-entry">Status: <span id="local-status">üìù Local Mode</span></div>
        <div class="menu-entry" id="github-setup">
          <span onclick="localEditor.setupGitHub()">Setup GitHub</span>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="frame">
  <main class="center-content">
    <div class="editor-header">
      <input type="text" id="postTitle" class="title-input" placeholder="Post Title">
    </div>
    
    <div class="editor-tools">
      <div class="editor-tools-left">
        <span id="category-btn" style="cursor: pointer; font-size: 12px; opacity: 0.7; padding: 4px 8px; border: 1px solid var(--border); background: var(--bg);">
          üìÅ <span id="current-category">General</span>
        </span>
      </div>
      
      <div class="editor-tools-right">
        <span id="export-btn" style="cursor: pointer; font-size: 12px; opacity: 0.7;">üì§ Export</span>
        <span id="publish-btn" style="display: none; cursor: pointer; font-size: 12px; opacity: 0.7;">üöÄ Publish</span>
      </div>
    </div>

    <div class="editor-main">
      <!-- Single Visual Editor -->
      <div id="visualEditor" class="visual-editor" contenteditable="true" 
           data-placeholder="Write your post content here using Markdown...

Select text and press Ctrl+M to add notes.">
      </div>
    </div>
  </main>
</div>

<!-- Category Selection Modal -->
<div id="categoryModal" class="modal">
  <div class="modal-content">
    <h3>üìÅ Select Category</h3>
    <div class="category-options">
      <div class="category-option" data-category="general">General</div>
      <div class="category-option" data-category="tech">Tech</div>
      <div class="category-option" data-category="personal">Personal</div>
      <div class="category-option" data-category="thoughts">Thoughts</div>
    </div>
    <div class="modal-buttons">
      <button onclick="localEditor.closeCategoryModal()" class="btn">Cancel</button>
    </div>
  </div>
</div>

<!-- Export Modal -->
<div id="exportModal" class="modal">
  <div class="modal-content">
    <h3>üì§ Export Post</h3>
    <p>Your post is ready! Copy the JSON below and save it as <strong><span id="export-filename"></span></strong> in your GitHub repository.</p>
    <p id="publish-mode" style="font-style: italic; opacity: 0.8;"></p>
    
    <textarea id="exportContent" readonly style="width: 100%; height: 300px; font-family: monospace; font-size: 12px;"></textarea>
    
    <div class="modal-buttons">
      <button onclick="localEditor.copyExport()" class="btn primary">üìã Copy JSON</button>
      <button onclick="localEditor.downloadExport()" class="btn">üíæ Download File</button>
      <button onclick="localEditor.closeExportModal()" class="btn">Close</button>
    </div>
  </div>
</div>

<!-- GitHub Setup Modal -->
<div id="githubModal" class="modal">
  <div class="modal-content">
    <h3>üîß Setup GitHub Publishing</h3>
    <p>Enter your GitHub details to publish posts directly:</p>
    
    <div style="margin: 15px 0;">
      <label><strong>GitHub Personal Access Token:</strong></label>
      <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxx">
      <small style="color: #666;">Create at: <a href="https://github.com/settings/tokens" target="_blank">github.com/settings/tokens</a> (needs repo scope)</small>
    </div>
    
    <div style="margin: 15px 0;">
      <label><strong>Repository:</strong></label>
      <input type="text" id="github-repo" placeholder="username/repository-name">
    </div>
    
    <div style="margin: 15px 0;">
      <label><strong>Branch:</strong></label>
      <input type="text" id="github-branch" value="main">
    </div>
    
    <div class="modal-buttons">
      <button onclick="localEditor.saveGitHubConfig()" class="btn primary">üíæ Save & Test</button>
      <button onclick="localEditor.closeGitHubModal()" class="btn">Cancel</button>
    </div>
  </div>
</div>

<!-- Message Modal -->
<div id="messageModal" class="modal">
  <div class="modal-content">
    <h3 id="messageTitle">Title</h3>
    <p id="messageContent">Content</p>
    <button onclick="localEditor.closeMessageModal()" class="btn primary">OK</button>
  </div>
</div>

<!-- Note Input Box -->
<div id="noteInput" style="display: none; position: absolute; z-index: 1000;">
  <input type="text" id="noteText" placeholder="Enter note text..." style="padding: 4px 8px; font-family: inherit; font-size: 12px; min-width: 200px;">
</div>

<style>
/* CSS Variables and Base Styles */
:root {
  --bg: #f7f7f7;
  --fg: #232323;
  --sidebar-bg: #eaeaea;
  --sidebar-fg: #232323;
  --accent: #3a7bd5;
  --menu-bg: var(--bg);
  --menu-fg: #232323;
  --border: #cccccc;
  --muted: #666666;
}

body.dark-mode {
  --bg: #272727;
  --fg: #acada8;
  --sidebar-bg: #232323;
  --sidebar-fg: #acada8;
  --accent: #c7c9c3;
  --menu-bg: var(--bg);
  --menu-fg: #acada8;
  --border: #343235;
  --muted: #6a696c;
  --link: #c7c9c3;
}

body {
  margin: 0;
  padding: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--fg);
  line-height: 1.5;
}

/* Menu Bar Styles */
.menu-bar {
  background: var(--menu-bg);
  border-bottom: 1px solid var(--border);
  padding: 0;
  height: 24px;
  position: relative;
  z-index: 1000;
}

.menu-bar-inner {
  display: flex;
  align-items: center;
  height: 100%;
  padding: 0 8px;
  font-size: 12px;
}

.menu-star {
  margin-right: 10px;
  font-weight: bold;
  color: var(--menu-fg);
}

.menu-item {
  position: relative;
  margin-right: 15px;
}

.menu-item .label {
  cursor: pointer;
  padding: 2px 8px;
  color: var(--menu-fg);
  border-radius: 2px;
}

.menu-item .label:hover {
  background: var(--accent);
  color: var(--bg);
}

.menu-item.open .label {
  background: var(--accent);
  color: var(--bg);
}

.menu-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: var(--menu-bg);
  border: 1px solid var(--border);
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  min-width: 120px;
  z-index: 1001;
}

.menu-item.open .menu-dropdown {
  display: block;
}

.menu-entry {
  display: block;
  padding: 6px 12px;
  color: var(--menu-fg);
  text-decoration: none;
  cursor: pointer;
  font-size: 12px;
  border-bottom: 1px solid var(--border);
}

.menu-entry:last-child {
  border-bottom: none;
}

.menu-entry:hover {
  background: var(--accent);
  color: var(--bg);
}

/* Use main page layout but with proper editor sizing */
.frame {
  display: flex;
  justify-content: center;
  height: calc(100vh - 24px);
  padding: 0 20px;
  box-sizing: border-box;
}

.center-content {
  width: 100%;
  max-width: 1000px;
  overflow-y: auto;
  padding: 20px;
  background: var(--bg);
  color: var(--fg);
  box-sizing: border-box;
}

.editor-header {
  margin-bottom: 20px;
}

.title-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  font-weight: normal;
  outline: none;
  box-sizing: border-box;
}

.title-input:focus {
  border-color: var(--accent);
}

.title-input::placeholder {
  color: rgba(172, 173, 168, 0.5);
  font-weight: normal;
}

.editor-tools {
  display: flex;
  gap: 15px;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  font-size: 12px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 10px;
}

.editor-tools-left {
  display: flex;
  gap: 15px;
  align-items: center;
}

.editor-tools-right {
  display: flex;
  gap: 10px;
  align-items: center;
}

.editor-tools span {
  color: var(--fg);
  opacity: 0.7;
  user-select: none;
}

.editor-tools span:hover {
  opacity: 1;
}

.editor-main {
  min-height: calc(100vh - 150px);
  width: 100%;
  flex: 1;
}

/* Visual Editor Styles */
.visual-editor {
  width: 100%;
  min-width: 0; /* Prevent flex shrinking issues */
  min-height: calc(100vh - 150px);
  padding: 20px;
  border: none;
  background: var(--bg);
  color: var(--fg);
  font-family: inherit;
  font-size: 13px;
  line-height: 1.55;
  outline: none;
  resize: none;
  box-sizing: border-box;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.visual-editor:empty::before {
  content: attr(data-placeholder);
  color: rgba(172, 173, 168, 0.3);
  white-space: pre-line;
  pointer-events: none;
}

/* Markdown styling in visual editor */
.visual-editor h1 {
  font-size: 1.8em;
  margin: 1em 0 0.5em 0;
  color: var(--fg);
  font-weight: normal;
}

.visual-editor h2 {
  font-size: 1.4em;
  margin: 1em 0 0.5em 0;
  color: var(--fg);
  font-weight: normal;
}

.visual-editor h3 {
  font-size: 1.2em;
  margin: 1em 0 0.5em 0;
  color: var(--fg);
  font-weight: normal;
}

.visual-editor p {
  margin: 1em 0;
}

.visual-editor strong {
  font-weight: bold;
}

.visual-editor em {
  font-style: italic;
}

/* Note links in visual editor */
.visual-editor .note-link {
  background-color: rgba(199, 201, 195, 0.15) !important;
  padding: 1px 3px !important;
  border-radius: 2px !important;
  cursor: help !important;
  border-bottom: 1px dotted var(--accent) !important;
  position: relative !important;
  text-decoration: none !important;
  display: inline !important;
}

.visual-editor .note-link:hover {
  background-color: rgba(199, 201, 195, 0.25) !important;
}

/* Raw editor styling */
.raw-editor {
  background: var(--bg) !important;
  color: var(--fg) !important;
  border: none !important;
  font-family: inherit !important;
  font-size: 13px !important;
  line-height: 1.55 !important;
}

/* Note input box */
#noteInput {
  border-radius: 3px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  background: var(--bg);
  border: 1px solid var(--border);
  padding: 2px;
}

#noteInput input {
  border-radius: 3px;
  outline: none;
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
}

#noteInput input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 1px var(--accent);
}

/* Modal overrides for remaining modals */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  z-index: 9999;
  justify-content: center;
  align-items: center;
}

.modal.show {
  display: flex !important;
}

.modal-content {
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 5px;
  padding: 20px;
  max-width: 90vw;
  max-height: 90vh;
  overflow-y: auto;
  margin: 0;
  position: relative;
  transform: none;
}

/* Category Modal Styles */
.category-options {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin: 15px 0;
  min-width: 200px;
}

.category-option {
  padding: 12px 16px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--fg);
  cursor: pointer;
  text-align: center;
  font-size: 14px;
  transition: all 0.2s;
}

.category-option:hover {
  background: var(--accent);
  color: var(--bg);
}

.category-option.selected {
  background: var(--accent);
  color: var(--bg);
  font-weight: bold;
}

.modal-content input,
.modal-content textarea,
.modal-content select {
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
}

.btn {
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border);
  padding: 4px 8px;
  font-size: 12px;
  font-family: inherit;
  cursor: pointer;
}

.btn:hover {
  background: var(--accent);
  color: var(--bg);
}

.btn.primary {
  background: var(--accent);
  color: var(--bg);
  border-color: var(--accent);
}

.btn.primary:hover {
  opacity: 0.8;
}

/* ULTRA-AGGRESSIVE Modal System - FORCE CENTERING NO MATTER WHAT */
.modal {
  display: none !important; /* Hidden by default */
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  background: rgba(0,0,0,0.5) !important;
  z-index: 99999 !important;
  justify-content: center !important;
  align-items: center !important;
  margin: 0 !important;
  padding: 0 !important;
  border: none !important;
  outline: none !important;
  transform: none !important;
  translate: none !important;
  scale: none !important;
  rotate: none !important;
}

.modal.show {
  display: flex !important; /* Only show when .show class is added */
}

/* ULTRA-AGGRESSIVE Modal content styling */
.modal-content {
  background: var(--bg) !important;
  color: var(--fg) !important;
  border: 1px solid var(--border) !important;
  border-radius: 5px !important;
  padding: 20px !important;
  max-width: 90vw !important;
  max-height: 90vh !important;
  overflow-y: auto !important;
  position: relative !important;
  margin: 0 auto !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
  top: auto !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
  transform: none !important;
  translate: none !important;
  scale: none !important;
  rotate: none !important;
  flex-shrink: 0 !important;
  align-self: center !important;
  justify-self: center !important;
}

/* NUCLEAR OPTION: Override ALL possible external modal styles */
div.modal, 
.modal, 
#exportModal, 
#categoryModal, 
#messageModal, 
#githubModal {
  display: none !important;
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  background: rgba(0,0,0,0.5) !important;
  z-index: 99999 !important;
  justify-content: center !important;
  align-items: center !important;
  margin: 0 !important;
  padding: 0 !important;
  border: none !important;
  outline: none !important;
  transform: none !important;
  translate: none !important;
  scale: none !important;
  rotate: none !important;
  box-sizing: border-box !important;
}

div.modal.show, 
.modal.show, 
#exportModal.show, 
#categoryModal.show, 
#messageModal.show, 
#githubModal.show {
  display: flex !important;
}
</style>

<script>
class LocalEditor {
  constructor() {
    this.currentDraft = null;
    this.isRawMode = false;
    this.currentCategory = 'general'; // Track selected category
    this.noteStore = new Map(); // Store note definitions separately
    this.init();
  }

  init() {
    this.checkGitHubConfig();
    this.setupEventListeners();
    this.setupVisualEditor();
    this.loadDraftsList(); // Now safe since it's a no-op
    this.autoSave();
  }

  setupEventListeners() {
    // Setup menus
    this.setupMenus();
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + M for make note
      if ((e.ctrlKey || e.metaKey) && e.key === 'm') {
        e.preventDefault();
        this.makeNote();
      }
      
      // Ctrl/Cmd + R for raw mode toggle
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        this.toggleRawMode();
      }
    });

    // View mode switching
    document.addEventListener('click', (e) => {
      if (e.target.hasAttribute('data-mode')) {
        const mode = e.target.getAttribute('data-mode');
        document.body.className = mode === 'dark' ? 'dark-mode' : '';
      }
    });

    // Toolbar clicks
    document.getElementById('export-btn').addEventListener('click', () => this.exportPost());
    const publishBtn = document.getElementById('publish-btn');
    if (publishBtn) {
      publishBtn.addEventListener('click', () => this.publishDirectly());
    }

    // Category button click
    document.getElementById('category-btn').addEventListener('click', () => this.showCategoryModal());

    // Set up universal modal management
    this.setupModalManagement();
  }

  setupModalManagement() {
    // Close modal when clicking outside of modal content
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal')) {
        this.closeModal(e.target.id);
      }
    });

    // Close modal with escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const openModal = document.querySelector('.modal.show');
        if (openModal) {
          this.closeModal(openModal.id);
        }
      }
    });

    // Set up specific close button handlers
    document.querySelectorAll('[onclick*="closeExportModal"]').forEach(btn => {
      btn.addEventListener('click', () => this.closeExportModal());
    });

    document.querySelectorAll('[onclick*="closeCategoryModal"]').forEach(btn => {
      btn.addEventListener('click', () => this.closeCategoryModal());
    });

    document.querySelectorAll('[onclick*="closeGitHubModal"]').forEach(btn => {
      btn.addEventListener('click', () => this.closeGitHubModal());
    });

    document.querySelectorAll('[onclick*="closeMessageModal"]').forEach(btn => {
      btn.addEventListener('click', () => this.closeMessageModal());
    });

    console.log('‚úÖ Modal management system initialized');
  }

  setupMenus() {
    document.querySelectorAll('[data-menu]').forEach(label => {
      label.addEventListener('click', () => {
        const item = label.parentElement;
        const open = item.classList.contains('open');
        document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('open'));
        if (!open) item.classList.add('open');
      });
    });
    document.addEventListener('click', e => {
      if (!e.target.closest('.menu-item'))
        document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('open'));
    });
  }

  setupVisualEditor() {
    const editor = document.getElementById('visualEditor');
    
    // Clear editor - start fresh
    editor.innerHTML = '';
    
    // Focus the editor after a brief delay
    setTimeout(() => {
      editor.focus();
    }, 100);
    
    // Handle input to process markdown in real-time
    editor.addEventListener('input', () => {
      this.processEditorContent();
    });

    // Handle paste to clean up content
    editor.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = e.clipboardData.getData('text/plain');
      document.execCommand('insertText', false, text);
    });

    // Enable hover notes functionality
    this.setupEditorHoverNotes();
  }

  processEditorContent() {
    const editor = document.getElementById('visualEditor');
    const content = editor.innerHTML;
    
    // Convert simple markdown patterns to styled elements
    // This runs in real-time as the user types
    this.applyMarkdownStyling();
  }

  applyMarkdownStyling() {
    const editor = document.getElementById('visualEditor');
    const selection = window.getSelection();
    const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
    
    // Save cursor position
    let cursorOffset = 0;
    if (range) {
      cursorOffset = range.startOffset;
    }

    // Process content but preserve note links
    let html = editor.innerHTML;
    
    // Convert markdown headers (but not inside note links)
    html = html.replace(/^# ([^<\n]+)$/gm, '<h1>$1</h1>');
    html = html.replace(/^## ([^<\n]+)$/gm, '<h2>$1</h2>');
    html = html.replace(/^### ([^<\n]+)$/gm, '<h3>$1</h3>');
    
    // Convert bold/italic (but not inside note links)
    html = html.replace(/\*\*([^*<]+)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*([^*<]+)\*/g, '<em>$1</em>');
    
    if (html !== editor.innerHTML) {
      editor.innerHTML = html;
      
      // Restore cursor position
      if (range) {
        try {
          const newRange = document.createRange();
          newRange.setStart(editor.firstChild || editor, cursorOffset);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } catch (e) {
          // Cursor restoration failed, place at end
          editor.focus();
        }
      }
    }
  }

  setupEditorHoverNotes() {
    console.log('Setting up editor hover notes...');
    
    // Create hover note tip element
    const tip = document.createElement('div');
    tip.id = 'editorHoverNote';
    tip.style.cssText = `
      position: absolute;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      max-width: 250px;
      word-wrap: break-word;
      z-index: 1000;
      display: none;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    `;
    document.body.appendChild(tip);

    const editor = document.getElementById('visualEditor');
    console.log('Visual editor found:', editor);

    function placeTip(x, y) {
      const pad = 10;
      const rect = tip.getBoundingClientRect();
      tip.style.left = Math.min(window.innerWidth - rect.width - pad, x + 14) + 'px';
      tip.style.top = Math.min(window.innerHeight - rect.height - pad, y + 18) + 'px';
    }

    // Use event delegation to handle dynamically added note links
    editor.addEventListener('mouseover', (e) => {
      // Check if the target or any parent has the note-link class
      let noteElement = e.target;
      while (noteElement && noteElement !== editor) {
        if (noteElement.classList && noteElement.classList.contains('note-link')) {
          const noteText = noteElement.getAttribute('data-note');
          if (noteText) {
            tip.textContent = noteText;
            tip.style.display = 'block';
            placeTip(e.clientX, e.clientY);
          }
          break;
        }
        noteElement = noteElement.parentNode;
      }
    });

    editor.addEventListener('mousemove', (e) => {
      if (tip.style.display === 'block') {
        placeTip(e.clientX, e.clientY);
      }
    });

    editor.addEventListener('mouseout', (e) => {
      // Check if we're still over a note link
      let stillOverNote = false;
      if (e.relatedTarget) {
        let element = e.relatedTarget;
        while (element && element !== editor) {
          if (element.classList && element.classList.contains('note-link')) {
            stillOverNote = true;
            break;
          }
          element = element.parentNode;
        }
      }
      
      if (!stillOverNote) {
        tip.style.display = 'none';
      }
    });
    
    console.log('Hover note event listeners attached with delegation');
  }

  getEditorContent() {
    if (this.isRawMode) {
      return document.getElementById('rawEditor').value;
    } else {
      return this.convertVisualToMarkdown();
    }
  }

  setEditorContent(content) {
    if (this.isRawMode) {
      document.getElementById('rawEditor').value = content;
    } else {
      this.convertMarkdownToVisual(content);
    }
  }

  convertVisualToMarkdown() {
    const editor = document.getElementById('visualEditor');
    let content = editor.innerHTML;
    
    // Convert HTML back to markdown
    content = content.replace(/<h1[^>]*>(.*?)<\/h1>/g, '# $1\n\n');
    content = content.replace(/<h2[^>]*>(.*?)<\/h2>/g, '## $1\n\n');
    content = content.replace(/<h3[^>]*>(.*?)<\/h3>/g, '### $1\n\n');
    content = content.replace(/<strong[^>]*>(.*?)<\/strong>/g, '**$1**');
    content = content.replace(/<em[^>]*>(.*?)<\/em>/g, '*$1*');
    content = content.replace(/<p[^>]*>(.*?)<\/p>/g, '$1\n\n');
    content = content.replace(/<br[^>]*>/g, '\n');
    
    // Clean up extra whitespace
    content = content.replace(/\n\n+/g, '\n\n').trim();
    
    return content;
  }

  convertMarkdownToVisual(content) {
    const editor = document.getElementById('visualEditor');
    let html = content;
    
    // Convert markdown to HTML
    html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
    html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
    html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    // Convert line breaks to paragraphs
    html = html.replace(/\n\n/g, '</p><p>');
    html = '<p>' + html + '</p>';
    html = html.replace(/<p><\/p>/g, '');
    html = html.replace(/<p>\s*<\/p>/g, '');
    
    editor.innerHTML = html;
  }

  toggleRawMode() {
    const visualEditor = document.getElementById('visualEditor');
    const rawEditor = document.getElementById('rawEditor');
    const viewModeToggle = document.getElementById('view-mode-toggle');
    
    if (!rawEditor) {
      // Create raw editor if it doesn't exist
      const textarea = document.createElement('textarea');
      textarea.id = 'rawEditor';
      textarea.className = 'raw-editor';
      textarea.style.cssText = `
        width: 100%;
        min-height: calc(100vh - 200px);
        padding: 20px;
        border: none;
        border-radius: 5px;
        font-family: inherit;
        font-size: 13px;
        line-height: 1.55;
        resize: vertical;
        display: none;
        background: var(--bg);
        color: var(--fg);
        box-sizing: border-box;
      `;
      visualEditor.parentNode.insertBefore(textarea, visualEditor.nextSibling);
    }
    
    if (this.isRawMode) {
      // Switch to visual mode
      const rawContent = document.getElementById('rawEditor').value;
      this.convertMarkdownToVisual(rawContent);
      visualEditor.style.display = 'block';
      document.getElementById('rawEditor').style.display = 'none';
      viewModeToggle.textContent = 'Raw Mode';
      this.isRawMode = false;
    } else {
      // Switch to raw mode
      const visualContent = this.convertVisualToMarkdown();
      document.getElementById('rawEditor').value = visualContent;
      visualEditor.style.display = 'none';
      document.getElementById('rawEditor').style.display = 'block';
      viewModeToggle.textContent = 'Visual Mode';
      this.isRawMode = true;
    }
  }

  newDocument() {
    if (this.getEditorContent().trim() && !confirm('Start new document? Unsaved changes will be lost.')) {
      return;
    }
    
    this.setEditorContent('');
    document.getElementById('postTitle').value = '';
    this.currentDraft = null;
    this.selectCategory('general');
    
    // Focus the title input first
    document.getElementById('postTitle').focus();
  }

  // Make Note functionality - streamlined
  makeNote() {
    const selection = window.getSelection();
    const selectedText = selection.toString().trim();
    
    if (!selectedText) {
      return; // Just do nothing if no text selected
    }
    
    // Store the current selection range for later use
    this.currentNoteSelection = selection.getRangeAt(0).cloneRange();
    this.currentSelectedText = selectedText;
    
    // Position and show note input
    const noteInput = document.getElementById('noteInput');
    const noteTextInput = document.getElementById('noteText');
    
    // Position near the selection
    const rect = this.currentNoteSelection.getBoundingClientRect();
    noteInput.style.left = rect.left + 'px';
    noteInput.style.top = (rect.bottom + 5) + 'px';
    noteInput.style.display = 'block';
    
    // Clear and focus input
    noteTextInput.value = '';
    noteTextInput.focus();
    
    // Handle enter key and escape
    const handleKeydown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.addNoteFromInput();
        noteTextInput.removeEventListener('keydown', handleKeydown);
      } else if (e.key === 'Escape') {
        this.cancelNoteInput();
        noteTextInput.removeEventListener('keydown', handleKeydown);
      }
    };
    
    noteTextInput.addEventListener('keydown', handleKeydown);
    
    // Handle blur (click outside)
    const handleBlur = () => {
      setTimeout(() => {
        if (noteTextInput.value.trim()) {
          this.addNoteFromInput();
        } else {
          this.cancelNoteInput();
        }
        noteTextInput.removeEventListener('blur', handleBlur);
      }, 100);
    };
    
    noteTextInput.addEventListener('blur', handleBlur);
  }

  addNoteFromInput() {
    const noteText = document.getElementById('noteText').value.trim();
    
    if (!noteText || !this.currentNoteSelection || !this.currentSelectedText) {
      this.cancelNoteInput();
      return;
    }
    
    // Create note link element
    const noteLink = document.createElement('span');
    noteLink.className = 'note-link';
    noteLink.setAttribute('data-note', noteText);
    noteLink.textContent = this.currentSelectedText;
    
    // Force the styling to ensure it appears correctly
    noteLink.style.cssText = `
      background-color: rgba(199, 201, 195, 0.15) !important;
      padding: 1px 3px !important;
      border-radius: 2px !important;
      cursor: help !important;
      border-bottom: 1px dotted var(--accent) !important;
      position: relative !important;
      text-decoration: none !important;
      display: inline !important;
    `;
    
    // Restore and use the saved selection
    const selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(this.currentNoteSelection);
    
    // Replace the selected text with the note link
    this.currentNoteSelection.deleteContents();
    this.currentNoteSelection.insertNode(noteLink);
    
    // Clear selection
    selection.removeAllRanges();
    
    // Focus back on the editor
    document.getElementById('visualEditor').focus();
    
    // Hide input and clean up
    this.cancelNoteInput();
  }

  cancelNoteInput() {
    document.getElementById('noteInput').style.display = 'none';
    this.currentNoteSelection = null;
    this.currentSelectedText = null;
  }

  setupModalManagement() {
    // List of remaining modals that need proper centering
    const modalIds = ['messageModal', 'exportModal', 'githubModal', 'categoryModal'];
    
    modalIds.forEach(modalId => {
      const modal = document.getElementById(modalId);
      if (modal) {
        // Ensure modal has the 'modal' class
        modal.classList.add('modal');
        
        // Add click-outside-to-close functionality
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            this.closeModal(modalId);
          }
        });

        // Ensure modal is centered
        this.ensureModalCentered(modalId);
      }
    });

    // Setup category modal options
    this.setupCategoryModal();
  }

  // Universal modal centering function - ULTRA AGGRESSIVE VERSION
  ensureModalCentered(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      console.log(`üìç ULTRA CENTERING modal: ${modalId}`);
      
      // STEP 1: Complete style reset
      modal.removeAttribute('style');
      modal.className = 'modal show';
      
      // STEP 2: Force maximum priority centering styles
      const centeredStyles = {
        'display': 'flex !important',
        'position': 'fixed !important',
        'top': '0 !important',
        'left': '0 !important',
        'right': '0 !important',
        'bottom': '0 !important',
        'width': '100vw !important',
        'height': '100vh !important',
        'justify-content': 'center !important',
        'align-items': 'center !important',
        'z-index': '99999 !important',
        'background': 'rgba(0,0,0,0.6) !important',
        'margin': '0 !important',
        'padding': '0 !important'
      };
      
      // Apply each style with maximum specificity
      Object.entries(centeredStyles).forEach(([prop, value]) => {
        modal.style.setProperty(prop, value.replace(' !important', ''), 'important');
      });
      
      // STEP 3: Ensure modal content doesn't interfere
      const modalContent = modal.querySelector('.modal-content');
      if (modalContent) {
        const contentStyles = {
          'position': 'relative !important',
          'margin': '0 !important',
          'transform': 'none !important',
          'max-width': '90vw !important',
          'max-height': '90vh !important',
          'left': 'auto !important',
          'top': 'auto !important',
          'right': 'auto !important',
          'bottom': 'auto !important'
        };
        
        Object.entries(contentStyles).forEach(([prop, value]) => {
          modalContent.style.setProperty(prop, value.replace(' !important', ''), 'important');
        });
      }
      
      // STEP 4: Force immediate reflow
      modal.offsetHeight; // Trigger reflow
      
      console.log(`‚úÖ ULTRA CENTERED modal ${modalId} - Position should be dead center`);
      console.log(`üìä Modal computed style:`, window.getComputedStyle(modal).display, window.getComputedStyle(modal).position);
    } else {
      console.error(`‚ùå Modal ${modalId} not found`);
    }
  }

  // Backup centering method using transform
  centerModalWithTransform(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      console.log(`üîÑ Using transform centering for: ${modalId}`);
      
      modal.style.cssText = `
        display: block !important;
        position: fixed !important;
        top: 50% !important;
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        z-index: 99999 !important;
        background: rgba(0,0,0,0.6) !important;
        width: auto !important;
        height: auto !important;
        max-width: 90vw !important;
        max-height: 90vh !important;
      `;
      
      // Add full-screen background overlay
      const overlay = document.createElement('div');
      overlay.id = modalId + '-overlay';
      overlay.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        background: rgba(0,0,0,0.3) !important;
        z-index: 99998 !important;
      `;
      
      // Remove existing overlay if any
      const existingOverlay = document.getElementById(modalId + '-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      document.body.appendChild(overlay);
      console.log(`‚úÖ Transform centering applied to ${modalId}`);
    }
  }

  // Debug modal positioning
  debugModalPosition(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      const rect = modal.getBoundingClientRect();
      const computed = window.getComputedStyle(modal);
      
      console.log(`üîç DEBUG ${modalId}:`);
      console.log(`   Display: ${computed.display}`);
      console.log(`   Position: ${computed.position}`);
      console.log(`   Top: ${computed.top}`);
      console.log(`   Left: ${computed.left}`);
      console.log(`   Transform: ${computed.transform}`);
      console.log(`   Z-Index: ${computed.zIndex}`);
      console.log(`   Bounds: x=${rect.x}, y=${rect.y}, w=${rect.width}, h=${rect.height}`);
      console.log(`   Viewport: ${window.innerWidth}x${window.innerHeight}`);
    }
  }

  setupCategoryModal() {
    document.querySelectorAll('.category-option').forEach(option => {
      option.addEventListener('click', () => {
        const category = option.getAttribute('data-category');
        this.selectCategory(category);
      });
    });
  }

  showCategoryModal() {
    // Highlight current category
    const currentCategory = this.getCurrentCategory();
    document.querySelectorAll('.category-option').forEach(option => {
      option.classList.remove('selected');
      if (option.getAttribute('data-category') === currentCategory) {
        option.classList.add('selected');
      }
    });
    
    this.showModal('categoryModal');
  }

  selectCategory(category) {
    this.currentCategory = category;
    document.getElementById('current-category').textContent = 
      category.charAt(0).toUpperCase() + category.slice(1);
    this.closeModal('categoryModal');
  }

  getCurrentCategory() {
    return this.currentCategory || 'general';
  }

  closeCategoryModal() {
    this.closeModal('categoryModal');
  }

  showModal(modalId) {
    console.log(`üé≠ SHOWING MODAL: ${modalId}`);
    const modal = document.getElementById(modalId);
    if (!modal) {
      console.error(`‚ùå Modal ${modalId} not found`);
      return;
    }
    
    // NUCLEAR OPTION: Complete modal reset and recreation
    this.forceModalReset(modal);
    
    console.log(`‚úÖ Modal ${modalId} displayed with forced reset`);
  }

  forceModalReset(modal) {
    // Step 1: Remove ALL existing classes and styles
    modal.className = '';
    modal.removeAttribute('style');
    
    // Step 2: Force the most basic possible centering
    modal.style.cssText = `
      display: flex !important;
      position: fixed !important;
      top: 0px !important;
      left: 0px !important;
      right: 0px !important;
      bottom: 0px !important;
      width: 100vw !important;
      height: 100vh !important;
      margin: 0px !important;
      padding: 0px !important;
      border: none !important;
      outline: none !important;
      background: rgba(0, 0, 0, 0.5) !important;
      z-index: 999999 !important;
      justify-content: center !important;
      align-items: center !important;
      box-sizing: border-box !important;
      transform: none !important;
      translate: none !important;
      scale: none !important;
      rotate: none !important;
      overflow: hidden !important;
    `;
    
    // Step 3: Also reset the modal content
    const content = modal.querySelector('.modal-content');
    if (content) {
      content.style.cssText = `
        position: relative !important;
        margin: 0px auto !important;
        padding: 20px !important;
        background: var(--bg, #2a2a2a) !important;
        color: var(--fg, #e8e8e8) !important;
        border: 1px solid var(--border, #555) !important;
        border-radius: 8px !important;
        max-width: 90vw !important;
        max-height: 90vh !important;
        overflow-y: auto !important;
        box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8) !important;
        box-sizing: border-box !important;
        transform: none !important;
        translate: none !important;
        scale: none !important;
        rotate: none !important;
        top: auto !important;
        left: auto !important;
        right: auto !important;
        bottom: auto !important;
        flex-shrink: 0 !important;
      `;
    }
    
    // Step 4: Log the final position for debugging
    setTimeout(() => {
      this.debugModalPosition(modalId);
    }, 50);
    
    console.log(`üöÄ Applied forced modal reset`);
  }

  debugModalPosition(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    const rect = modal.getBoundingClientRect();
    const computed = window.getComputedStyle(modal);
    console.log(`üìä Modal ${modalId} debug info:`);
    console.log(`   Display: ${computed.display}`);
    console.log(`   Position: ${computed.position}`);
    console.log(`   Top: ${computed.top}, Left: ${computed.left}`);
    console.log(`   Transform: ${computed.transform}`);
    console.log(`   Z-Index: ${computed.zIndex}`);
    console.log(`   Bounds: x=${rect.x}, y=${rect.y}, w=${rect.width}, h=${rect.height}`);
    console.log(`   Viewport: ${window.innerWidth}x${window.innerHeight}`);
    
    // Check if modal content is visible
    const content = modal.querySelector('.modal-content');
    if (content) {
      const contentRect = content.getBoundingClientRect();
      console.log(`   Content bounds: x=${contentRect.x}, y=${contentRect.y}, w=${contentRect.width}, h=${contentRect.height}`);
      
      const isVisible = (
        contentRect.x >= 0 && 
        contentRect.y >= 0 && 
        contentRect.x + contentRect.width <= window.innerWidth && 
        contentRect.y + contentRect.height <= window.innerHeight
      );
      
      console.log(`   Content fully visible: ${isVisible ? 'YES ‚úÖ' : 'NO ‚ùå'}`);
      
      if (!isVisible) {
        console.log(`   üö® MODAL POSITIONING ISSUE DETECTED!`);
        if (contentRect.x < 0) console.log(`   üìç Content extends ${Math.abs(contentRect.x)}px off LEFT edge`);
        if (contentRect.y < 0) console.log(`   üìç Content extends ${Math.abs(contentRect.y)}px off TOP edge`);
        if (contentRect.x + contentRect.width > window.innerWidth) {
          console.log(`   üìç Content extends ${(contentRect.x + contentRect.width) - window.innerWidth}px off RIGHT edge`);
        }
        if (contentRect.y + contentRect.height > window.innerHeight) {
          console.log(`   üìç Content extends ${(contentRect.y + contentRect.height) - window.innerHeight}px off BOTTOM edge`);
        }
      }
    }
  }

  closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = 'none';
      modal.className = '';
      modal.removeAttribute('style');
      console.log(`‚úÖ Modal ${modalId} closed and reset`);
    }
  }

  // Auto-save every 30 seconds
  autoSave() {
    setInterval(() => {
      const content = this.getEditorContent().trim();
      if (content) {
        this.saveDraft(true); // Silent save
      }
    }, 30000);
  }

  saveDraft(silent = false) {
    const content = this.getEditorContent().trim();
    const title = document.getElementById('postTitle').value.trim();
    const category = this.getCurrentCategory();
    
    if (!content && !title) {
      if (!silent) this.showMessage('Error', 'Nothing to save');
      return;
    }

    const draftTitle = title || this.extractTitle(content) || 'Untitled Draft';
    const draftId = this.currentDraft?.id || 'draft-' + Date.now();
    
    const draft = {
      id: draftId,
      title: draftTitle,
      content: content,
      category: category,
      created: this.currentDraft?.created || new Date().toISOString(),
      modified: new Date().toISOString()
    };

    // Save to localStorage
    const drafts = this.getDrafts();
    const existingIndex = drafts.findIndex(d => d.id === draftId);
    
    if (existingIndex >= 0) {
      drafts[existingIndex] = draft;
    } else {
      drafts.push(draft);
    }
    
    localStorage.setItem('localDrafts', JSON.stringify(drafts));
    this.currentDraft = draft;
    
    if (!silent) {
      this.showMessage('Success', 'Draft saved locally!');
    }
  }

  loadDraft(draftId) {
    const drafts = this.getDrafts();
    const draft = drafts.find(d => d.id === draftId);
    
    if (draft) {
      this.setEditorContent(draft.content);
      document.getElementById('postTitle').value = draft.title;
      this.selectCategory(draft.category);
      this.currentDraft = draft;
    }
  }

  exportPost() {
    const content = this.getEditorContent().trim();
    const title = document.getElementById('postTitle').value.trim();
    const category = this.getCurrentCategory();
    
    if (!content && !title) {
      this.showMessage('Error', 'Nothing to export');
      return;
    }

    const postTitle = title || this.extractTitle(content) || 'Untitled Post';
    const slug = this.generateSlug(postTitle);
    const date = new Date().toISOString().split('T')[0];
    
    const postData = {
      title: postTitle,
      date: this.formatDateForPost(date),
      content: this.processContent(content),
      category: category
    };
    
    // Show export modal
    document.getElementById('export-filename').textContent = `${slug}.json`;
    document.getElementById('exportContent').value = JSON.stringify(postData, null, 2);
    this.showModal('exportModal');
  }

  async publishDirectly() {
    const content = this.getEditorContent().trim();
    const title = document.getElementById('postTitle').value.trim();
    const category = this.getCurrentCategory();
    
    if (!content && !title) {
      this.showMessage('Error', 'Nothing to publish');
      return;
    }

    const config = this.getGitHubConfig();
    if (!config) {
      this.showMessage('Error', 'GitHub not configured. Click "Setup GitHub Publishing" first.');
      return;
    }

    const postTitle = title || this.extractTitle(content) || 'Untitled Post';
    const slug = this.generateSlug(postTitle);
    const date = new Date().toISOString().split('T')[0];
    
    const postData = {
      title: postTitle,
      date: this.formatDateForPost(date),
      content: this.processContent(content),
      category: category
    };

    try {
      // Upload the post file
      await this.uploadToGitHub(`posts/${slug}.json`, postData, `Add post: ${postTitle}`, config);
      
      // Update the index
      await this.updatePostIndex(slug, postTitle, date, category, config);
      
      this.showMessage('Success', `Post "${postTitle}" published successfully to GitHub!`);
      
      // Clear editor and title
      this.setEditorContent('');
      document.getElementById('postTitle').value = '';
      this.currentDraft = null;
      
    } catch (error) {
      this.showMessage('Error', `Failed to publish: ${error.message}`);
    }
  }

  deleteDraft(draftId) {
    if (!confirm('Delete this draft?')) return;
    
    const drafts = this.getDrafts();
    const filtered = drafts.filter(d => d.id !== draftId);
    localStorage.setItem('localDrafts', JSON.stringify(filtered));
    
    if (this.currentDraft?.id === draftId) {
      this.currentDraft = null;
    }
    
    this.showMessage('Success', 'Draft deleted');
  }

  copyExport() {
    const exportContent = document.getElementById('exportContent');
    exportContent.select();
    document.execCommand('copy');
    this.showMessage('Success', 'JSON copied to clipboard!');
  }

  downloadExport() {
    const content = document.getElementById('exportContent').value;
    const filename = document.getElementById('export-filename').textContent;
    
    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
    
    this.showMessage('Success', 'File downloaded!');
  }

  closeExportModal() {
    this.closeModal('exportModal');
  }

  getDrafts() {
    const stored = localStorage.getItem('localDrafts');
    return stored ? JSON.parse(stored) : [];
  }

  loadDraftsList() {
    // Drafts sidebar was removed, so this is now a no-op
    // Could implement a drafts modal later if needed
  }

  showDraftsList() {
    const drafts = this.getDrafts();
    if (drafts.length === 0) {
      this.showMessage('No Drafts', 'No saved drafts found.');
      return;
    }
    
    const draftsList = drafts.map((draft, index) => 
      `${index + 1}. ${draft.title} (${new Date(draft.modified).toLocaleDateString()})`
    ).join('\n');
    
    const selection = prompt(`Select a draft to load:\n\n${draftsList}\n\nEnter the number (1-${drafts.length}):`);
    const draftIndex = parseInt(selection) - 1;
    
    if (draftIndex >= 0 && draftIndex < drafts.length) {
      this.loadDraft(drafts[draftIndex].id);
      this.showMessage('Success', `Loaded draft: ${drafts[draftIndex].title}`);
    }
  }

  manageDrafts() {
    const drafts = this.getDrafts();
    const exportAll = confirm(`You have ${drafts.length} drafts. Export all as ZIP file?`);
    
    if (exportAll && drafts.length > 0) {
      // Simple implementation - just show all drafts data
      const allData = JSON.stringify(drafts, null, 2);
      const blob = new Blob([allData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'all-drafts.json';
      a.click();
      URL.revokeObjectURL(url);
    }
  }

  extractTitle(content) {
    const lines = content.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.startsWith('# ')) {
        return trimmed.substring(2).trim();
      }
    }
    return null;
  }

  generateSlug(title) {
    return title.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .substring(0, 50);
  }

  processContent(content) {
    // Remove title line if it exists
    const lines = content.split('\n');
    if (lines[0].trim().startsWith('# ')) {
      lines.shift();
      if (lines[0]?.trim() === '') lines.shift();
    }
    return lines.join('\n').trim();
  }

  formatDateForPost(dateStr) {
    const date = new Date(dateStr);
    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December'];
    return `${date.getFullYear()}-${months[date.getMonth()]}-${date.getDate()}`;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  showMessage(title, content) {
    console.log(`üì¢ Showing message: ${title}`);
    document.getElementById('messageTitle').textContent = title;
    document.getElementById('messageContent').textContent = content;
    this.showModal('messageModal');
  }

  closeExportModal() {
    this.closeModal('exportModal');
  }

  closeMessageModal() {
    this.closeModal('messageModal');
  }

  closeGitHubModal() {
    this.closeModal('githubModal');
  }

  // GitHub Integration Methods
  checkGitHubConfig() {
    const config = this.getGitHubConfig();
    if (config && config.token && config.repo) {
      document.getElementById('github-setup').innerHTML = 
        '<span class="github-connected">‚úÖ GitHub connected</span> ' +
        '<button onclick="localEditor.setupGitHub()" class="btn" style="margin-left: 10px;">‚öôÔ∏è Edit</button>';
      document.getElementById('publish-mode').textContent = 'or publish directly to GitHub!';
      document.getElementById('publish-btn').style.display = 'inline-block';
      document.getElementById('export-btn').classList.remove('primary');
    }
  }

  setupGitHub() {
    const config = this.getGitHubConfig() || {};
    document.getElementById('github-token').value = config.token || '';
    document.getElementById('github-repo').value = config.repo || '';
    document.getElementById('github-branch').value = config.branch || 'main';
    this.showModal('githubModal');
  }

  async saveGitHubConfig() {
    const token = document.getElementById('github-token').value.trim();
    const repo = document.getElementById('github-repo').value.trim();
    const branch = document.getElementById('github-branch').value.trim() || 'main';

    if (!token || !repo) {
      this.showMessage('Error', 'Please fill in all required fields');
      return;
    }

    // Test the configuration
    try {
      const response = await fetch(`https://api.github.com/repos/${repo}`, {
        headers: {
          'Authorization': `token ${token}`,
          'User-Agent': 'ppPage-Blog'
        }
      });

      if (!response.ok) {
        throw new Error(`GitHub API error: ${response.status}`);
      }

      // Save configuration
      const config = { token, repo, branch };
      localStorage.setItem('githubConfig', JSON.stringify(config));
      
      this.closeModal('githubModal');
      this.checkGitHubConfig();
      this.showMessage('Success', 'GitHub configuration saved and tested!');
      
    } catch (error) {
      this.showMessage('Error', `Failed to connect to GitHub: ${error.message}`);
    }
  }

  async publishDirectly() {
    const content = this.getEditorContent().trim();
    const category = document.getElementById('categorySelect').value;
    
    if (!content) {
      this.showMessage('Error', 'Nothing to publish');
      return;
    }

    const config = this.getGitHubConfig();
    if (!config) {
      this.showMessage('Error', 'GitHub not configured. Click "Setup GitHub Publishing" first.');
      return;
    }

    const title = this.extractTitle(content) || 'Untitled Post';
    const slug = this.generateSlug(title);
    const date = new Date().toISOString().split('T')[0];
    
    const postData = {
      title: title,
      date: this.formatDateForPost(date),
      content: this.processContent(content),
      category: category
    };

    try {
      // Upload the post file
      await this.uploadToGitHub(`posts/${slug}.json`, postData, `Add post: ${title}`, config);
      
      // Update the index
      await this.updatePostIndex(slug, title, date, category, config);
      
      this.showMessage('Success', `Post "${title}" published successfully to GitHub!`);
      
      // Clear editor
      this.setEditorContent('');
      this.currentDraft = null;
      
    } catch (error) {
      this.showMessage('Error', `Failed to publish: ${error.message}`);
    }
  }

  async uploadToGitHub(path, content, message, config) {
    const { token, repo, branch } = config;
    
    // Check if file exists to get SHA
    let sha = null;
    try {
      const response = await fetch(`https://api.github.com/repos/${repo}/contents/${path}?ref=${branch}`, {
        headers: {
          'Authorization': `token ${token}`,
          'User-Agent': 'ppPage-Blog'
        }
      });
      if (response.ok) {
        const data = await response.json();
        sha = data.sha;
      }
    } catch (error) {
      // File doesn't exist, that's fine
    }

    // Upload the file
    const uploadData = {
      message: message,
      content: btoa(JSON.stringify(content, null, 2)),
      branch: branch
    };
    
    if (sha) {
      uploadData.sha = sha;
    }

    const response = await fetch(`https://api.github.com/repos/${repo}/contents/${path}`, {
      method: 'PUT',
      headers: {
        'Authorization': `token ${token}`,
        'Content-Type': 'application/json',
        'User-Agent': 'ppPage-Blog'
      },
      body: JSON.stringify(uploadData)
    });

    if (!response.ok) {
      const error = await response.json();
      console.error('GitHub API Error:', error);
      console.error('Response status:', response.status);
      console.error('Trying to access:', `${repo}/contents/${path}`);
      throw new Error(`GitHub API Error (${response.status}): ${error.message || error.error || 'Upload failed'}`);
    }

    return response.json();
  }

  async updatePostIndex(slug, title, date, category, config) {
    try {
      // Get current index
      const response = await fetch(`https://api.github.com/repos/${config.repo}/contents/posts/index.json?ref=${config.branch}`, {
        headers: {
          'Authorization': `token ${config.token}`,
          'User-Agent': 'ppPage-Blog'
        }
      });

      let indexContent = [];
      let sha = null;

      if (response.ok) {
        const data = await response.json();
        indexContent = JSON.parse(atob(data.content));
        sha = data.sha;
      }

      // Add new post (check if already exists first)
      const existingIndex = indexContent.findIndex(post => post.slug === slug);
      const newEntry = {
        slug: slug,
        title: title,
        date: this.formatDateForPost(date),
        category: category
      };

      if (existingIndex >= 0) {
        indexContent[existingIndex] = newEntry;
      } else {
        indexContent.push(newEntry);
      }

      // Sort by date (newest first)
      indexContent.sort((a, b) => new Date(b.date) - new Date(a.date));

      // Upload updated index
      await this.uploadToGitHub('posts/index.json', indexContent, `Update index for post: ${title}`, config);
      
    } catch (error) {
      console.warn('Failed to update index:', error);
      // Don't throw - the post was still uploaded successfully
    }
  }

  getGitHubConfig() {
    const stored = localStorage.getItem('githubConfig');
    return stored ? JSON.parse(stored) : null;
  }

  closeGitHubModal() {
    this.closeModal('githubModal');
  }

  // Make Note functionality
  makeNote() {
    const selection = window.getSelection();
    if (selection.rangeCount === 0) {
      this.showMessage('No Selection', 'Please select some text first to add a note.');
      return;
    }

    const selectedText = selection.toString().trim();
    if (!selectedText) {
      this.showMessage('No Selection', 'Please select some text first to add a note.');
      return;
    }

    // Prompt for note text
    const noteText = prompt(`Add a note to "${selectedText}":`);
    if (!noteText) return;

    // Create note link element
    const range = selection.getRangeAt(0);
    const noteSpan = document.createElement('span');
    noteSpan.className = 'note-link';
    noteSpan.setAttribute('data-note', noteText);
    noteSpan.textContent = selectedText;
    
    try {
      range.deleteContents();
      range.insertNode(noteSpan);
      selection.removeAllRanges();
      
      console.log('‚úÖ Note added successfully');
    } catch (error) {
      console.error('Error adding note:', error);
      this.showMessage('Error', 'Failed to add note. Please try again.');
    }
  }

  // Toggle Raw Mode functionality (placeholder)
  toggleRawMode() {
    // For now, just show a message that this feature is coming
    this.showMessage('Coming Soon', 'Raw mode toggle will be available in a future update.');
  }
}

// Initialize when page loads
const localEditor = new LocalEditor();
</script>

</body>
</html>
