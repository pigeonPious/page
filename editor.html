<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="editor.css">
</head>
<body>

<!-- Taskbar will be loaded by shared-taskbar.js -->

<!-- Main Editor -->
<div class="frame">
  <main class="center-content">
    <div class="editor-main-column">
      <div class="editor-header">
        <input type="text" id="postTitle" class="title-input" placeholder="...">
      </div>
      
      <div class="editor-main">
        <div id="visualEditor" class="visual-editor" contenteditable="true" 
             data-placeholder="Write your post content here using Markdown...

Select text and press Ctrl+M to add notes.">
        </div>
      </div>
    </div>
  </main>
  
  <div class="editor-sidebar">
    <div class="editor-tools-vertical">
      <div class="tool-button" id="category-btn">
        CATEGORY
        <span class="tool-value" id="current-category">General</span>
      </div>
      
      <div class="tool-button" id="images-btn">
        IMAGES
        <span class="tool-value">Manage Images</span>
      </div>
      
      <div class="tool-button" id="export-btn">
        EXPORT
      </div>
      
      <div class="tool-button" id="publish-btn">
        PUBLISH
      </div>
    </div>
  </div>
</div>

<!-- Security Notice for Public Users -->
<div id="securityNotice" class="modal">
  <div class="modal-content">
    <h3>üîí Security Notice</h3>
    <div style="text-align: left; margin: 15px 0;">
      <p><strong>This editor is safe to use publicly!</strong></p>
      
      <p><strong>For Visitors:</strong></p>
      <ul>
        <li>‚úÖ Read and explore published posts</li>
        <li>‚úÖ Use the editor for local drafts (saved in your browser)</li>
        <li>‚úÖ Export posts as HTML or text files</li>
        <li>‚ùå Cannot publish to this site without GitHub token</li>
      </ul>

      <p><strong>To Publish Your Own Posts:</strong></p>
      <ol>
        <li>Create your own GitHub repository</li>
        <li>Get a GitHub Personal Access Token (with repo permissions)</li>
        <li>Use Connect > Setup GitHub to configure your own publishing</li>
        <li>Your token stays private in YOUR browser only</li>
      </ol>
      
      <p><strong>Privacy:</strong> Your drafts and GitHub tokens are stored locally in your browser and never shared with others.</p>
    </div>
    
    <div class="modal-buttons">
      <button onclick="editor.closeModal('securityNotice')" class="btn primary">Got it!</button>
      <input type="checkbox" id="dontShowAgain" style="margin: 0 5px;"> Don't show again
    </div>
  </div>
</div>

<!-- Category Selection Modal -->
<div id="categoryModal" class="modal">
  <div class="modal-content">
    <h3>Select Category</h3>
    <div class="category-options">
      <div class="category-option" data-category="general">General</div>
      <div class="category-option" data-category="tech">Tech</div>
      <div class="category-option" data-category="personal">Personal</div>
      <div class="category-option" data-category="thoughts">Thoughts</div>
    </div>
    <div class="modal-buttons">
      <button onclick="editor.closeModal('categoryModal')" class="btn">Cancel</button>
    </div>
  </div>
</div>

<!-- GitHub Setup Modal -->
<div id="githubModal" class="modal">
  <div class="modal-content">
    <h3>Setup GitHub Publishing</h3>
    <p>Enter your GitHub details to publish posts directly:</p>
    
    <div style="margin: 15px 0;">
      <label><strong>GitHub Personal Access Token:</strong></label>
      <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxx">
      <small style="color: #666;">Create at: <a href="https://github.com/settings/tokens" target="_blank">github.com/settings/tokens</a> (needs repo scope)</small>
    </div>
    
    <div style="margin: 15px 0;">
      <label><strong>Repository:</strong></label>
      <input type="text" id="github-repo" placeholder="username/repository-name">
    </div>
    
    <div style="margin: 15px 0;">
      <label><strong>Branch:</strong></label>
      <input type="text" id="github-branch" value="main">
    </div>
    
    <div class="modal-buttons">
      <button onclick="editor.saveGitHubConfig()" class="btn primary">Save & Test</button>
      <button onclick="editor.closeModal('githubModal')" class="btn">Cancel</button>
    </div>
  </div>
</div>

<!-- Drafts Modal -->
<div id="draftsModal" class="modal">
  <div class="modal-content">
    <h3>Your Drafts</h3>
    <div id="drafts-list"></div>
    <div class="modal-buttons">
      <button onclick="editor.closeModal('draftsModal')" class="btn">Close</button>
    </div>
  </div>
</div>

<!-- Message Modal -->
<div id="messageModal" class="modal">
  <div class="modal-content">
    <h3 id="message-title">Simple Editor</h3>
    <p id="message-content"></p>
    <div class="modal-buttons">
      <button onclick="editor.closeModal('messageModal')" class="btn primary">OK</button>
    </div>
  </div>
</div>

<!-- Box Style 1 Inputs -->
<div id="noteInputBox" class="box-style-1 hidden">
  <input type="text" placeholder="Enter your note..." maxlength="200">
</div>

<div id="publishInputBox" class="box-style-1 hidden">
  <input type="text" placeholder="Commit message (optional)..." maxlength="100">
</div>

<div id="exportInputBox" class="box-style-1 hidden">
  <input type="text" placeholder="Filename (optional)..." maxlength="50">
</div>

<div id="messageBox" class="box-style-1 message-box hidden">
  <span class="message-text">Message will appear here</span>
</div>

<!-- Image Magazine - Draggable Box Style 1 Frame -->
<div id="imageMagazine" class="box-style-1 image-magazine hidden">
  <div class="image-magazine-header">
    <span class="image-magazine-title">üñºÔ∏è Image Magazine</span>
    <div class="image-magazine-controls">
      <button class="image-magazine-btn" id="import-image-btn">üì§ Import</button>
      <button class="image-magazine-btn close-btn" id="close-magazine-btn">√ó</button>
    </div>
  </div>
  <div class="image-magazine-content">
    <div class="image-gallery" id="imageGallery">
      <div class="no-images-message">
        <p>No images found in repository</p>
        <p><small>Click Import to add images</small></p>
      </div>
    </div>
  </div>
</div>

<!-- Hidden file input for image upload -->
<input type="file" id="imageFileInput" accept="image/*" multiple style="display: none;">

<script>
// Simple Editor - Optimized and Clean
const editor = {
  // Core state
  currentCategory: 'general',
  isRawMode: false,
  noteCounter: 1,

  // Initialize editor
  init() {
    this.setupEventListeners();
    // this.setupMenus(); // Disabled - using shared taskbar menu system
    this.setupModalManagement();
    this.setupImageMagazine();
    this.checkGitHubConfig();
    console.log('Simple Editor initialized');
    
    // Update the global function now that editor is ready
    window.makeNoteFromTaskbar = () => this.makeNote();
  },

  // Event listeners
  setupEventListeners() {
    // Category button
    document.getElementById('category-btn').addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent text deselection
    });
    document.getElementById('category-btn').addEventListener('click', () => this.showModal('categoryModal'));
    
    // Export button
    document.getElementById('export-btn').addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent text deselection
    });
    document.getElementById('export-btn').addEventListener('click', () => this.exportPost());
    
    // Images button
    document.getElementById('images-btn').addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent text deselection
    });
    document.getElementById('images-btn').addEventListener('click', () => this.toggleImageMagazine());
    
    // Publish button
    document.getElementById('publish-btn').addEventListener('mousedown', (e) => {
      e.preventDefault(); // Prevent text deselection
    });
    document.getElementById('publish-btn').addEventListener('click', () => this.publishPost());
    
    // Category options
    document.querySelectorAll('.category-option').forEach(option => {
      option.addEventListener('click', () => {
        this.currentCategory = option.dataset.category;
        document.getElementById('current-category').textContent = 
          option.textContent;
        this.closeModal('categoryModal');
      });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'm') {
        e.preventDefault();
        this.makeNote();
      }
      if (e.key === 'Escape') {
        this.closeAllModals();
        this.hideImageMagazine();
      }
    });

    // Image magazine event listeners
    this.setupImageEventListeners();
  },

  // Menu system
  setupMenus() {
    document.querySelectorAll('[data-menu]').forEach(menu => {
      menu.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Prevent text deselection
      });
      
      menu.addEventListener('click', (e) => {
        e.stopPropagation();
        
        // Close other menus
        document.querySelectorAll('.menu-item').forEach(item => {
          if (item !== menu.parentElement) {
            item.classList.remove('open');
          }
        });
        
        // Toggle current menu
        menu.parentElement.classList.toggle('open');
      });
    });

    // Prevent text deselection on menu entries too
    document.querySelectorAll('.menu-entry').forEach(entry => {
      entry.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Prevent text deselection
      });
    });

    // Close menus when clicking outside
    document.addEventListener('click', () => {
      document.querySelectorAll('.menu-item').forEach(item => {
        item.classList.remove('open');
      });
    });

    // Mode switching
    document.querySelectorAll('[data-mode]').forEach(modeBtn => {
      modeBtn.addEventListener('click', () => {
        const mode = modeBtn.dataset.mode;
        document.body.className = mode === 'dark' ? 'dark-mode' : '';
      });
    });
  },

  // Modal management
  setupModalManagement() {
    // Click outside to close
    document.querySelectorAll('.modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeModal(modal.id);
        }
      });
    });
  },

  showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    // Force reset all positioning
    modal.style.cssText = '';
    modal.classList.add('show');
    
    console.log(`Showing modal: ${modalId}`);
  },

  closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    
    modal.classList.remove('show');
    console.log(`Closed modal: ${modalId}`);
  },

  closeAllModals() {
    document.querySelectorAll('.modal').forEach(modal => {
      modal.classList.remove('show');
    });
  },

  // Box Style 1 Input System
  showBoxInput(boxId, onConfirm, initialValue = '') {
    const box = document.getElementById(boxId);
    const input = box.querySelector('input');
    
    // Position the box near the cursor or button
    const selection = window.getSelection();
    let x = 100, y = 100;
    
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      x = rect.left;
      y = rect.bottom + 5;
    }
    
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.classList.remove('hidden');
    
    input.value = initialValue;
    input.focus();
    input.select();
    
    // Handle Enter and Escape
    const handleKeydown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const value = input.value.trim();
        this.hideBoxInput(boxId);
        if (onConfirm) onConfirm(value);
        input.removeEventListener('keydown', handleKeydown);
        document.removeEventListener('click', handleClickOutside);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        this.hideBoxInput(boxId);
        input.removeEventListener('keydown', handleKeydown);
        document.removeEventListener('click', handleClickOutside);
      }
    };
    
    // Handle click outside
    const handleClickOutside = (e) => {
      if (!box.contains(e.target)) {
        this.hideBoxInput(boxId);
        input.removeEventListener('keydown', handleKeydown);
        document.removeEventListener('click', handleClickOutside);
      }
    };
    
    input.addEventListener('keydown', handleKeydown);
    setTimeout(() => {
      document.addEventListener('click', handleClickOutside);
    }, 100);
  },

  hideBoxInput(boxId) {
    const box = document.getElementById(boxId);
    box.classList.add('hidden');
  },

  // Document management
  newDocument() {
    document.getElementById('postTitle').value = '';
    document.getElementById('visualEditor').innerHTML = '';
    this.currentCategory = 'general';
    document.getElementById('current-category').textContent = 'General';
    console.log('New document created');
  },

  // Note functionality
  makeNote() {
    console.log('makeNote() called');
    const selection = window.getSelection();
    
    if (selection.rangeCount === 0) {
      this.showMessage('Select some text first to create a note.');
      return;
    }

    const range = selection.getRangeAt(0);
    const selectedText = range.toString().trim();
    
    if (!selectedText) {
      this.showMessage('Please select some text to create a note.');
      return;
    }

    // Store selection data for later use
    this.pendingNoteData = { range, selectedText };
    
    // Show box style 1 input
    this.showBoxInput('noteInputBox', (noteText) => {
      if (!noteText.trim()) return;
      
      // Create note link
      const noteId = `note-${this.noteCounter++}`;
      const noteLink = document.createElement('span');
      noteLink.className = 'note-link';
      noteLink.dataset.noteId = noteId;
      noteLink.dataset.note = noteText;
      noteLink.title = noteText;
      noteLink.textContent = selectedText;

      // Replace selection with note link
      this.pendingNoteData.range.deleteContents();
      this.pendingNoteData.range.insertNode(noteLink);
      
      selection.removeAllRanges();
      console.log(`Created note: ${noteId}`);
    });
  },

  toggleRawMode() {
    this.isRawMode = !this.isRawMode;
    const toggle = document.getElementById('view-mode-toggle');
    toggle.textContent = this.isRawMode ? 'Visual Mode' : 'Raw Mode';
    console.log(`Toggled to ${this.isRawMode ? 'raw' : 'visual'} mode`);
  },

  // Export functionality
  exportPost() {
    const title = document.getElementById('postTitle').value.trim();
    if (!title) {
      this.showMessage('Please enter a title for your post.');
      return;
    }

    const rawContent = document.getElementById('visualEditor').innerHTML;
    if (!rawContent.trim()) {
      this.showMessage('Please write some content for your post.');
      return;
    }

    // Convert visual content to markdown-friendly format
    const content = this.convertToMarkdown(rawContent);

    // Generate default filename
    const defaultFilename = title.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    
    // Show box style 1 input for filename
    this.showBoxInput('exportInputBox', (filename) => {
      const finalFilename = filename || defaultFilename;
      
      const post = {
        title,
        content,
        category: this.currentCategory,
        date: new Date().toISOString(),
        id: finalFilename,
        notes: this.extractNotes()
      };

      // Download file directly
      const jsonContent = JSON.stringify(post, null, 2);
      const blob = new Blob([jsonContent], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${finalFilename}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      this.showMessage(`Exported: ${finalFilename}.json`);
    }, defaultFilename);
  },

  extractNotes() {
    const noteLinks = document.querySelectorAll('.note-link');
    const notes = {};
    noteLinks.forEach(link => {
      notes[link.dataset.noteId] = link.dataset.note;
    });
    return notes;
  },

  copyExport() {
    const content = document.getElementById('exportContent');
    content.select();
    document.execCommand('copy');
    this.showMessage('Exported JSON copied to clipboard!');
  },

  downloadExport() {
    const content = document.getElementById('exportContent').value;
    const filename = document.getElementById('export-filename').textContent;
    
    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.showMessage('File downloaded successfully!');
  },

  // Draft management
  saveDraft() {
    const title = document.getElementById('postTitle').value.trim() || 'Untitled Draft';
    const content = document.getElementById('visualEditor').innerHTML;
    
    const draft = {
      title,
      content,
      category: this.currentCategory,
      saved: new Date().toISOString()
    };

    const drafts = JSON.parse(localStorage.getItem('drafts') || '[]');
    drafts.push(draft);
    localStorage.setItem('drafts', JSON.stringify(drafts));
    
    this.showMessage(`Draft "${title}" saved successfully!`);
  },

  showDraftsList() {
    const drafts = JSON.parse(localStorage.getItem('drafts') || '[]');
    const list = document.getElementById('drafts-list');
    
    if (drafts.length === 0) {
      list.innerHTML = '<p>No drafts saved yet.</p>';
    } else {
      list.innerHTML = drafts.map((draft, index) => `
        <div style="border: 1px solid var(--border); padding: 10px; margin: 5px 0; border-radius: 3px;">
          <strong>${draft.title}</strong><br>
          <small>Category: ${draft.category} | Saved: ${new Date(draft.saved).toLocaleDateString()}</small><br>
          <button onclick="editor.loadDraft(${index})" class="btn primary" style="margin: 5px 5px 0 0;">Load</button>
          <button onclick="editor.deleteDraft(${index})" class="btn">Delete</button>
        </div>
      `).join('');
    }
    
    this.showModal('draftsModal');
  },

  loadDraft(index) {
    const drafts = JSON.parse(localStorage.getItem('drafts') || '[]');
    const draft = drafts[index];
    
    if (draft) {
      document.getElementById('postTitle').value = draft.title;
      document.getElementById('visualEditor').innerHTML = draft.content;
      this.currentCategory = draft.category;
      document.getElementById('current-category').textContent = 
        draft.category.charAt(0).toUpperCase() + draft.category.slice(1);
      
      this.closeModal('draftsModal');
      this.showMessage('Draft loaded successfully!');
    }
  },

  deleteDraft(index) {
    if (confirm('Are you sure you want to delete this draft?')) {
      const drafts = JSON.parse(localStorage.getItem('drafts') || '[]');
      drafts.splice(index, 1);
      localStorage.setItem('drafts', JSON.stringify(drafts));
      this.showDraftsList(); // Refresh the list
    }
  },

  manageDrafts() {
    this.showDraftsList();
  },

  // GitHub integration
  checkGitHubConfig() {
    const config = this.getGitHubConfig();
    const statusElement = document.getElementById('github-status');
    
    if (!statusElement) return; // Not on editor page
    
    if (config && config.token && config.repo) {
      statusElement.textContent = 'connected';
      statusElement.style.color = 'var(--accent)';
      document.getElementById('publish-btn').style.display = 'block';
    } else {
      statusElement.textContent = 'not connected';
      statusElement.style.color = 'var(--muted)';
      document.getElementById('publish-btn').style.display = 'block';
    }
  },

  setupGitHub() {
    const config = this.getGitHubConfig() || {};
    document.getElementById('github-token').value = config.token || '';
    document.getElementById('github-repo').value = config.repo || '';
    document.getElementById('github-branch').value = config.branch || 'main';
    
    this.showModal('githubModal');
  },

  saveGitHubConfig() {
    const token = document.getElementById('github-token').value.trim();
    const repo = document.getElementById('github-repo').value.trim();
    const branch = document.getElementById('github-branch').value.trim() || 'main';

    if (!token || !repo) {
      this.showMessage('Please fill in both token and repository fields.');
      return;
    }

    const config = { token, repo, branch };
    localStorage.setItem('githubConfig', JSON.stringify(config));
    
    this.closeModal('githubModal');
    this.checkGitHubConfig();
    this.showMessage('GitHub configuration saved successfully!');
  },

  getGitHubConfig() {
    try {
      return JSON.parse(localStorage.getItem('githubConfig'));
    } catch {
      return null;
    }
  },

  async publishPost() {
    console.log('publishPost() called!');
    
    const title = document.getElementById('postTitle').value.trim();
    const content = document.getElementById('visualEditor').innerHTML.trim();
    
    if (!title) {
      this.showMessage('Please enter a title for your post.');
      return;
    }
    
    if (!content) {
      this.showMessage('Please write some content for your post.');
      return;
    }

    // Check GitHub config
    const config = this.getGitHubConfig();
    if (!config || !config.token || !config.repo) {
      this.showMessage('Please set up GitHub configuration first. Go to Connect > Setup GitHub.', 'Setup Required');
      return;
    }

    // Show box style 1 input for commit message
    this.showBoxInput('publishInputBox', async (commitMessage) => {
      const finalCommitMessage = commitMessage || `Add post: ${title}`;
      
      // Generate post data
      const slug = this.generateSlug(title);
      const date = new Date().toISOString().split('T')[0];
      const formattedDate = this.formatDateForPost(date);
      
      const postData = {
        title: title,
        content: this.processContent(content),
        category: this.currentCategory,
        date: formattedDate
      };

      console.log('Publishing to GitHub:', postData);

      try {
        // Save post to GitHub with custom commit message
        await this.savePostToGitHub(slug, postData, config, finalCommitMessage);
        
        this.showMessage('Post published successfully to GitHub!', 'üéâ Success');
        
        // Clear editor
        document.getElementById('postTitle').value = '';
        document.getElementById('visualEditor').innerHTML = '';
        this.currentCategory = 'general';
        document.getElementById('current-category').textContent = 'General';
        
      } catch (error) {
        console.error('Error publishing post:', error);
        this.showMessage(error.message || 'Failed to publish post to GitHub.', '‚ùå Error');
      }
    }, `Add post: ${title}`);
  },

  async savePostToGitHub(slug, postData, config, commitMessage = null) {
    const [owner, repo] = config.repo.split('/');
    const branch = config.branch || 'main';
    
    // Use custom commit message or default
    const message = commitMessage || `Add post: ${postData.title}`;
    
    // Save post file
    const postPath = `posts/${slug}.json`;
    const postContent = JSON.stringify(postData, null, 2);
    
    await this.createOrUpdateGitHubFile(
      owner, repo, branch, postPath, 
      message, 
      postContent, config.token
    );

    // Update index
    await this.updatePostIndex(owner, repo, branch, slug, postData, config.token);
  },

  async createOrUpdateGitHubFile(owner, repo, branch, path, message, content, token) {
    // First, try to get the existing file to get its SHA
    let sha = null;
    try {
      const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`, {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });
      
      if (response.ok) {
        const file = await response.json();
        sha = file.sha;
      }
    } catch (error) {
      // File doesn't exist, that's fine
    }

    // Create or update the file
    const payload = {
      message: message,
      content: btoa(content),
      branch: branch
    };
    
    if (sha) {
      payload.sha = sha;
    }

    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
      method: 'PUT',
      headers: {
        'Authorization': `token ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`GitHub API error: ${error.message}`);
    }

    return response.json();
  },

  async updatePostIndex(owner, repo, branch, slug, postData, token) {
    try {
      // Get current index
      const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/posts/index.json?ref=${branch}`, {
        headers: {
          'Authorization': `token ${token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });

      let indexContent = [];
      let sha = null;

      if (response.ok) {
        const indexFile = await response.json();
        indexContent = JSON.parse(atob(indexFile.content));
        sha = indexFile.sha;
      }

      // Add new post to index (remove existing if updating)
      indexContent = indexContent.filter(post => post.slug !== slug);
      indexContent.push({
        slug: slug,
        title: postData.title,
        date: postData.date,
        category: postData.category || 'general'
      });

      // Sort by date (newest first)
      indexContent.sort((a, b) => new Date(b.date) - new Date(a.date));

      // Update index file
      await this.createOrUpdateGitHubFile(
        owner, repo, branch, 'posts/index.json',
        `Update index for post: ${postData.title}`,
        JSON.stringify(indexContent, null, 2),
        token
      );

    } catch (error) {
      console.error('Error updating index:', error);
      throw new Error('Failed to update post index');
    }
  },

  formatDateForPost(dateStr) {
    const date = new Date(dateStr);
    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                   'July', 'August', 'September', 'October', 'November', 'December'];
    return `${date.getFullYear()}-${months[date.getMonth()]}-${date.getDate()}`;
  },

  // Helper functions for publishing
  generateSlug(title) {
    return title.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  },

  processContent(content) {
    // Convert HTML content to preserve formatting and note links
    return content;
  },

  // Utility functions
  showMessage(message, title = 'Simple Editor') {
    // Use Box Style 1 for validation and simple messages
    if (this.isValidationMessage(message)) {
      this.showBoxMessage(message);
    } else {
      // Use modal for complex messages
      document.getElementById('message-title').textContent = title;
      document.getElementById('message-content').textContent = message;
      this.showModal('messageModal');
    }
  },

  isValidationMessage(message) {
    // Determine if this is a simple validation message that should use Box Style 1
    const validationKeywords = [
      'Please enter a title',
      'Please write some content',
      'Please select some text',
      'Please fill in',
      'Please enter',
      'Please write'
    ];
    return validationKeywords.some(keyword => message.includes(keyword));
  },

  showBoxMessage(message) {
    const box = document.getElementById('messageBox');
    const textSpan = box.querySelector('.message-text');
    
    textSpan.textContent = message;
    
    // Get mouse position, or use center if no mouse data
    let x = window.lastMouseX || (window.innerWidth / 2 - 150);
    let y = window.lastMouseY || (window.innerHeight / 3);
    
    // Offset the popup slightly below and to the right of the mouse
    x += 10;
    y += 10;
    
    // Ensure popup stays within viewport boundaries
    const boxWidth = 300; // Approximate width
    const boxHeight = 50; // Approximate height
    
    if (x + boxWidth > window.innerWidth) {
      x = window.innerWidth - boxWidth - 10;
    }
    if (y + boxHeight > window.innerHeight) {
      y = window.innerHeight - boxHeight - 10;
    }
    if (x < 10) x = 10;
    if (y < 10) y = 10;
    
    box.style.left = x + 'px';
    box.style.top = y + 'px';
    box.classList.remove('hidden');
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
      box.classList.add('hidden');
    }, 3000);
  },

  // =============================================================================
  // IMAGE MANAGEMENT FUNCTIONS
  // =============================================================================

  // Initialize image magazine functionality
  setupImageMagazine() {
    this.imageMagazineVisible = false;
    this.draggedImage = null;
    this.images = []; // Store available images
    
    // Load existing images from GitHub
    this.loadImagesFromRepository();
  },

  // Setup image-related event listeners
  setupImageEventListeners() {
    // Import button
    document.getElementById('import-image-btn').addEventListener('click', () => {
      document.getElementById('imageFileInput').click();
    });

    // Close magazine button
    document.getElementById('close-magazine-btn').addEventListener('click', () => {
      this.hideImageMagazine();
    });

    // File input change
    document.getElementById('imageFileInput').addEventListener('change', (e) => {
      this.handleImageUpload(e.target.files);
      e.target.value = ''; // Reset input
    });

    // Make magazine draggable
    this.setupMagazineDragging();

    // Setup visual editor as drop zone
    this.setupVisualEditorDropZone();
  },

  // Toggle image magazine visibility
  toggleImageMagazine() {
    if (this.imageMagazineVisible) {
      this.hideImageMagazine();
    } else {
      this.showImageMagazine();
    }
  },

  // Show image magazine
  showImageMagazine() {
    const magazine = document.getElementById('imageMagazine');
    magazine.classList.remove('hidden');
    
    // Position magazine (default center-right)
    const x = window.innerWidth - 370;
    const y = 100;
    magazine.style.left = Math.max(20, x) + 'px';
    magazine.style.top = y + 'px';
    
    this.imageMagazineVisible = true;
    this.refreshImageGallery();
  },

  // Hide image magazine
  hideImageMagazine() {
    document.getElementById('imageMagazine').classList.add('hidden');
    this.imageMagazineVisible = false;
  },

  // Make magazine draggable
  setupMagazineDragging() {
    const magazine = document.getElementById('imageMagazine');
    const header = magazine.querySelector('.image-magazine-header');
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    header.addEventListener('mousedown', (e) => {
      if (e.target.closest('.image-magazine-btn')) return; // Don't drag when clicking buttons
      
      isDragging = true;
      const rect = magazine.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
      
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('mouseup', stopDrag);
      e.preventDefault();
    });

    function handleDrag(e) {
      if (!isDragging) return;
      
      const x = e.clientX - dragOffset.x;
      const y = e.clientY - dragOffset.y;
      
      // Keep within viewport
      const maxX = window.innerWidth - magazine.offsetWidth;
      const maxY = window.innerHeight - magazine.offsetHeight;
      
      magazine.style.left = Math.max(0, Math.min(maxX, x)) + 'px';
      magazine.style.top = Math.max(0, Math.min(maxY, y)) + 'px';
    }

    function stopDrag() {
      isDragging = false;
      document.removeEventListener('mousemove', handleDrag);
      document.removeEventListener('mouseup', stopDrag);
    }
  },

  // Load images from GitHub repository
  async loadImagesFromRepository() {
    try {
      const config = this.getGitHubConfig();
      if (!config || !config.token || !config.repo) {
        console.log('GitHub not configured, using demo images');
        this.images = this.getDemoImages();
        return;
      }

      const [owner, repo] = config.repo.split('/');
      const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/assets`, {
        headers: {
          'Authorization': `token ${config.token}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      });

      if (response.ok) {
        const files = await response.json();
        this.images = files
          .filter(file => file.type === 'file' && /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(file.name))
          .map(file => ({
            name: file.name,
            url: file.download_url,
            path: file.path,
            sha: file.sha
          }));
      } else {
        console.log('Assets folder not found, using demo images');
        this.images = this.getDemoImages();
      }
    } catch (error) {
      console.error('Error loading images:', error);
      this.images = this.getDemoImages();
    }
  },

  // Get demo images if no repository is configured
  getDemoImages() {
    return [
      {
        name: 'sample.gif',
        url: 'assets/sample.gif',
        path: 'assets/sample.gif',
        isDemo: true
      }
    ];
  },

  // Refresh the image gallery display
  refreshImageGallery() {
    const gallery = document.getElementById('imageGallery');
    
    if (this.images.length === 0) {
      gallery.innerHTML = `
        <div class="no-images-message">
          <p>No images found in repository</p>
          <p><small>Click Import to add images</small></p>
        </div>
      `;
      return;
    }

    gallery.innerHTML = this.images.map(image => `
      <div class="image-item" data-image-name="${image.name}" data-image-url="${image.url}" data-image-path="${image.path}">
        <img src="${image.url}" alt="${image.name}" loading="lazy">
        <div class="image-name">${image.name}</div>
      </div>
    `).join('');

    // Add drag functionality to image items
    gallery.querySelectorAll('.image-item').forEach(item => {
      this.setupImageDragging(item);
    });
  },

  // Setup dragging for individual images
  setupImageDragging(imageItem) {
    let isDragging = false;
    let dragClone = null;

    imageItem.addEventListener('mousedown', (e) => {
      isDragging = true;
      
      // Create drag clone
      dragClone = imageItem.cloneNode(true);
      dragClone.classList.add('image-dragging');
      dragClone.style.position = 'fixed';
      dragClone.style.width = '80px';
      dragClone.style.height = '80px';
      dragClone.style.zIndex = '9999';
      dragClone.style.pointerEvents = 'none';
      document.body.appendChild(dragClone);

      // Store image data for dropping
      this.draggedImage = {
        name: imageItem.dataset.imageName,
        url: imageItem.dataset.imageUrl,
        path: imageItem.dataset.imagePath
      };

      document.addEventListener('mousemove', handleImageDrag);
      document.addEventListener('mouseup', stopImageDrag);
      e.preventDefault();
    });

    const handleImageDrag = (e) => {
      if (!isDragging || !dragClone) return;
      
      dragClone.style.left = (e.clientX - 40) + 'px';
      dragClone.style.top = (e.clientY - 40) + 'px';
    };

    const stopImageDrag = (e) => {
      if (!isDragging) return;
      
      isDragging = false;
      
      // Check if dropped on visual editor
      const visualEditor = document.getElementById('visualEditor');
      const rect = visualEditor.getBoundingClientRect();
      
      if (e.clientX >= rect.left && e.clientX <= rect.right &&
          e.clientY >= rect.top && e.clientY <= rect.bottom) {
        this.insertImageIntoEditor(this.draggedImage);
      }

      // Cleanup
      if (dragClone) {
        document.body.removeChild(dragClone);
        dragClone = null;
      }
      this.draggedImage = null;
      
      document.removeEventListener('mousemove', handleImageDrag);
      document.removeEventListener('mouseup', stopImageDrag);
      
      // Remove drag-over styling
      visualEditor.classList.remove('drag-over');
    };
  },

  // Setup visual editor as drop zone
  setupVisualEditorDropZone() {
    const visualEditor = document.getElementById('visualEditor');

    // Handle drag over
    visualEditor.addEventListener('dragover', (e) => {
      e.preventDefault();
      visualEditor.classList.add('drag-over');
    });

    // Handle drag leave
    visualEditor.addEventListener('dragleave', (e) => {
      if (!visualEditor.contains(e.relatedTarget)) {
        visualEditor.classList.remove('drag-over');
      }
    });

    // Handle drop
    visualEditor.addEventListener('drop', (e) => {
      e.preventDefault();
      visualEditor.classList.remove('drag-over');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        this.handleImageUpload(files);
      }
    });

    // Also handle mouse events for our custom dragging
    visualEditor.addEventListener('mouseenter', (e) => {
      if (this.draggedImage) {
        visualEditor.classList.add('drag-over');
      }
    });

    visualEditor.addEventListener('mouseleave', () => {
      visualEditor.classList.remove('drag-over');
    });
  },

  // Handle image file upload
  async handleImageUpload(files) {
    const config = this.getGitHubConfig();
    
    if (!config || !config.token || !config.repo) {
      this.showMessage('GitHub Setup Required', 'Please configure GitHub connection in Connect > Setup GitHub to upload images.');
      return;
    }

    for (const file of files) {
      if (!file.type.startsWith('image/')) {
        this.showMessage('Invalid File', `${file.name} is not an image file.`);
        continue;
      }

      try {
        await this.uploadImageToGitHub(file, config);
        this.showMessage('Upload Success', `${file.name} uploaded successfully!`);
      } catch (error) {
        console.error('Upload error:', error);
        this.showMessage('Upload Failed', `Failed to upload ${file.name}: ${error.message}`);
      }
    }

    // Refresh the image gallery
    await this.loadImagesFromRepository();
    this.refreshImageGallery();
  },

  // Upload image to GitHub repository
  async uploadImageToGitHub(file, config) {
    const [owner, repo] = config.repo.split('/');
    
    // Read file as base64
    const base64Content = await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const base64 = e.target.result.split(',')[1]; // Remove data:image/... prefix
        resolve(base64);
      };
      reader.readAsDataURL(file);
    });

    // Create unique filename to avoid conflicts
    const timestamp = Date.now();
    const filename = `${timestamp}-${file.name}`;
    const path = `assets/${filename}`;

    const payload = {
      message: `Add image: ${filename}`,
      content: base64Content,
      branch: config.branch || 'main'
    };

    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
      method: 'PUT',
      headers: {
        'Authorization': `token ${config.token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`GitHub API error: ${error.message}`);
    }

    return response.json();
  },

  // Insert image into the visual editor
  insertImageIntoEditor(imageData) {
    const visualEditor = document.getElementById('visualEditor');
    
    // Create image preview container
    const imageContainer = document.createElement('div');
    imageContainer.className = 'editor-image-preview';
    imageContainer.contentEditable = false; // Prevent editing of the image itself
    imageContainer.dataset.imageName = imageData.name;
    imageContainer.dataset.imagePath = imageData.path;
    imageContainer.dataset.imageUrl = imageData.url;
    
    // Create the visual image
    const img = document.createElement('img');
    img.src = imageData.url;
    img.alt = imageData.name;
    img.style.maxWidth = '100%';
    img.style.height = 'auto';
    img.style.display = 'block';
    
    // Create image info overlay
    const imageInfo = document.createElement('div');
    imageInfo.className = 'editor-image-info';
    imageInfo.innerHTML = `
      <span class="image-filename">üì∑ ${imageData.name}</span>
      <span class="image-actions">
        <button class="image-action-btn" onclick="editor.editImageAlt(this)" title="Edit Alt Text">‚úèÔ∏è</button>
        <button class="image-action-btn" onclick="editor.removeImage(this)" title="Remove Image">üóëÔ∏è</button>
      </span>
    `;
    
    // Add elements to container
    imageContainer.appendChild(img);
    imageContainer.appendChild(imageInfo);
    
    // Add click handler for full-size viewing
    img.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent container click
      this.showFullSizeImage(imageData);
    });

    // Add click handler for container (show info)
    imageContainer.addEventListener('click', () => {
      this.showMessage('Image Info', `Image: ${imageData.name}\nPath: ${imageData.path}\nClick the image to view full size\nClick the edit button to change alt text`);
    });

    // Insert at cursor position or at the end
    const selection = window.getSelection();
    if (selection.rangeCount > 0 && visualEditor.contains(selection.focusNode)) {
      const range = selection.getRangeAt(0);
      range.deleteContents();
      range.insertNode(imageContainer);
      
      // Add line breaks for better spacing
      const brBefore = document.createElement('br');
      const brAfter = document.createElement('br');
      imageContainer.parentNode.insertBefore(brBefore, imageContainer);
      imageContainer.parentNode.insertBefore(brAfter, imageContainer.nextSibling);
      
      // Move cursor after the image
      range.setStartAfter(brAfter);
      range.setEndAfter(brAfter);
      selection.removeAllRanges();
      selection.addRange(range);
    } else {
      // Append to end if no selection
      visualEditor.appendChild(document.createElement('br'));
      visualEditor.appendChild(imageContainer);
      visualEditor.appendChild(document.createElement('br'));
    }
    
    this.showMessage('Image Added', `${imageData.name} has been added to your post!`);
  },

  // Edit image alt text
  editImageAlt(button) {
    const container = button.closest('.editor-image-preview');
    const img = container.querySelector('img');
    const currentAlt = img.alt;
    
    this.showBoxInput('noteInputBox', (newAlt) => {
      if (newAlt !== null && newAlt !== undefined) {
        img.alt = newAlt || container.dataset.imageName;
        this.showMessage('Alt Text Updated', 'Image alt text has been updated.');
      }
    }, currentAlt);
  },

  // Remove image from editor
  removeImage(button) {
    const container = button.closest('.editor-image-preview');
    const imageName = container.dataset.imageName;
    
    if (confirm(`Remove image "${imageName}" from your post?`)) {
      // Remove the container and surrounding line breaks
      const prev = container.previousSibling;
      const next = container.nextSibling;
      
      if (prev && prev.nodeName === 'BR') prev.remove();
      if (next && next.nodeName === 'BR') next.remove();
      
      container.remove();
      this.showMessage('Image Removed', `${imageName} has been removed from your post.`);
    }
  },

  // Show full-size image in modal
  showFullSizeImage(imageData) {
    // Create modal for full-size image
    const modal = document.createElement('div');
    modal.className = 'image-modal';
    modal.innerHTML = `
      <div class="image-modal-overlay">
        <div class="image-modal-content">
          <div class="image-modal-header">
            <span class="image-modal-title">üì∑ ${imageData.name}</span>
            <button class="image-modal-close">√ó</button>
          </div>
          <div class="image-modal-body">
            <img src="${imageData.url}" alt="${imageData.name}" class="full-size-image">
          </div>
          <div class="image-modal-footer">
            <small>Path: ${imageData.path}</small>
          </div>
        </div>
      </div>
    `;

    // Add to document
    document.body.appendChild(modal);

    // Add event listeners
    const closeBtn = modal.querySelector('.image-modal-close');
    const overlay = modal.querySelector('.image-modal-overlay');

    closeBtn.addEventListener('click', () => {
      document.body.removeChild(modal);
    });

    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        document.body.removeChild(modal);
      }
    });

    // ESC key to close
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        document.body.removeChild(modal);
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);
  },

  // Convert visual content to markdown format
  convertToMarkdown(htmlContent) {
    // Create a temporary container to parse the HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;

    // Convert image previews to markdown
    const imagePreviews = tempDiv.querySelectorAll('.editor-image-preview');
    imagePreviews.forEach(preview => {
      const img = preview.querySelector('img');
      const imagePath = preview.dataset.imagePath;
      const altText = img.alt || preview.dataset.imageName;
      
      // Create markdown image syntax
      const markdown = `![${altText}](${imagePath})`;
      
      // Replace the preview with markdown text
      const textNode = document.createTextNode(markdown);
      preview.parentNode.replaceChild(textNode, preview);
    });

    // Convert other HTML elements to markdown-friendly format
    let content = tempDiv.innerHTML;
    
    // Basic HTML to markdown conversions
    content = content
      .replace(/<br\s*\/?>/gi, '\n')
      .replace(/<\/p>/gi, '\n\n')
      .replace(/<p[^>]*>/gi, '')
      .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
      .replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**')
      .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
      .replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*')
      .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n')
      .replace(/<h2[^>]*>(.*?)<\/h2>/gi, '## $1\n')
      .replace(/<h3[^>]*>(.*?)<\/h3>/gi, '### $1\n')
      .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\n')
      .replace(/<h5[^>]*>(.*?)<\/h5>/gi, '##### $1\n')
      .replace(/<h6[^>]*>(.*?)<\/h6>/gi, '###### $1\n');

    // Clean up extra whitespace and line breaks
    content = content
      .replace(/\n{3,}/g, '\n\n')
      .replace(/^\s+|\s+$/g, '')
      .trim();

    return content;
  }
};

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Track mouse position for popup anchoring
  document.addEventListener('mousemove', (e) => {
    window.lastMouseX = e.clientX;
    window.lastMouseY = e.clientY;
  });
  
  // Make makeNote function available globally BEFORE taskbar loads
  window.makeNoteFromTaskbar = () => {
    if (typeof editor !== 'undefined' && editor.makeNote) {
      editor.makeNote();
    } else {
      console.log('Make note not available yet');
    }
  };
  
  editor.init();
});

// For backwards compatibility
const localEditor = editor;
</script>

<!-- Load shared scripts after the main editor is defined -->
<script src="shared-taskbar.js"></script>
<script src="script.js"></script>

</body>
</html>
